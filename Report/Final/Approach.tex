%!TEX root = Main.tex
% Design Approach: words
\chapter{Design Theory and Approach} % (fold)
\label{cha:design_approach}

% High level system overview - what exactly was built, where each of the pieces fit, what I needed to learn to build each section.
% Analyse my solution - what does it do, where does it fall short

\section{The HMM based model} % (fold)
\label{sec:the_hmm_based_model}
	Due to the flexibility of HMMs, and the complexity of speech, there have been several different approaches to building speech models (the sheer size of the HTK book indicates how much flexibility exists).  However, at this stage the author is more interested in the implementation of the algorithms, rather than devising the best way of modelling speech.  Therefore, it was decided to use the pre-designed models from Voxforge for this project, and build the hardware to work with these models.  Thus, various parameters were fixed from the start, including:

	\begin{itemize}
		\item Sampling rate of audio: 8kHz (Low Pass Filter with $\omega_0 = 4kHz$ required).
		\item Window size: 25ms (length of observation vectors).
		\item Frame period: 10ms (time between observation vectors).
		\item Number of components per observation: 25 (12 MFCCs, 12 derivatives, 1 Energy).
		\item Output probabilities: Single Gaussian distribution, 25-element mean and variance vectors.
		\item Number of monophones: 51 (Includes a monophone for silence.  This is also the number of transition matrices).
		\item Number of senones: ~7000.
		\item Number of HMMs: ~8300\footnote{There are more HMMs than senones because some senones are used in more than one HMM}.
	\end{itemize}

	The only modification made to the Voxforge models was that they were adapted for the author's voice, primarily to gain confidence with using the HTK and HMMs.  Please see Appendix !!TODO!! for the scripts and HTK configuration files used to generate these models.

	The senones are context dependent, that is, there are many different senones for each monophone, each with different predecessor and successor monophones.  Most of the HMMs have 3 emitting states, and 2 states used to model entering and leaving a certain sequence. The number of transition matrices is equal to the number of monophones because...
	% TODO: tidy up the description of my models.  Maybe this needs a whole section??
% section the_hmm_based_model (end)

\section{Detailed Goal Specification} % (fold)
\label{sec:goal_specification}
	As described in previous sections, the FPGA is intended to be used for scoring every senone in the model, for every observation vector.  In this system the new vectors arrive once every 10ms, and there are about 7000 senones that must be evaluated.  The mathematical operations required to do this are now outlined. % !!TODO!! some kind of 'this is x calculations'?

	Each senone $j$ has an $N$-element vector of means, $\mu_j$, and a $N\times N$ matrix of covariances, $\sigma_j$.  However, since MFCCs are uncorrelated, the covariance matrix is diagonal, and $\sigma_j$ is taken as an $N$-element vector.  If the observation vector at time $t$ is denoted as $\mathbf{O}_t = {O_{t1}, O_{t2}, ..., O_{tN}}$, then the score of senone $j$ is given in Equation~\ref{eq:score1}.  However, the hardware complexity may be greatly reduced by taking the logs of both sides, removing the requirement to evaluate $N$ exponentials for each senone.  In addition, several parts of the equation may be precomputed, thus reducing the necessary sequence of operations to subtract, square, multiply, and accumulate.  This derivation is shown in Equations \ref{eq:score_ln}--\ref{eq:score_final}, with the final result being the one most suited to hardware implementation.

	\begin{equation}
	\label{eq:score1}
		b_j(O_t) = N(O_t; \mu_j,\sigma_j) = product...
	\end{equation}
	\begin{equation}
	\label{eq:score_ln}
		ln of both sides
	\end{equation}
	\begin{equation}
	\label{eq:score_final}
		final equation with subs (TODO)
	\end{equation}

	The hardware related goals outlined in Chapters 1 and 2 can be summarised as
	\begin{itemize}
		\item Design a system in programmable logic that can efficiently evaluate Equation~!!!.
		\item Design a C program to pre-process speech data according to the required form described in Section~\ref{sec:the_hmm_based_model}.
	\end{itemize}
% section goal_specification (end)


\section{FPGAs} % (fold)
\label{sec:fpgas}
% Write about what FPGAs have to offer for speech recognition
% ... "In a real speaker independent, context-dependent system there could be thousands of these states, each requiring a large number of calculations, depending on how complex the models are."

% section fpgas (end)


\section{System Overview} % (fold)
\label{sec:system_overview}
	The overall system layout, shown in Figure~\ref{fig:hlsystem} is comprised of two primary blocks -- L'Imperatrice and La Papessa (referred to from now on as ``The processor'' and ``The FPGA'' respectively). The entire system is powered from a single supply connected to the processor board's battery connector, and the FPGA is powered through ribbon cable connecting the two boards.  This was done in order to minimise the amount of external circuitry needed, and to show that the two devices are able to work together fairly easily.

	The two boards communicate over UART at approximately !!!11.5kbps!!! (115200 baud rate).

	% How to display which tasks are accomplished by which parts?

	% TODO:
	% Diagram of the ribbon cable connections (ie which pins do what)
	% Write about the software side (Lisp, parsing hmms etc)
	% There's both hardware, and support software

	\begin{figure}[tb]
		\begin{center}
			\includegraphics[width=\textwidth]{high-level-system-overview.png}
		\end{center}
		\caption{High level system layout overview}
		\label{fig:hlsystem}
	\end{figure}
% section system_overview (end)


\section{Analysis of Solution} % (fold)
\label{sec:analysis_of_solution}

	\subsection{The FPGA} % (fold)
	\label{sub:the_fpga}
		The FPGA used (Xilinx !!TODO!!) was very small, and the full required design could not fit on it.  In particular, the size of the model had to be reduced, so that each Senone had fewer than 25 components, and not all 7000 senones were processed.  This is mainly due to the small amount of onboard RAM on the FPGA, so the design would greatly benefit from having more RAM available.
	% subsection the_fpga (end)

	% The fixed point accuracy? 16 bit?

	% The communication method (UART) is extremely slow and is the weakest point of the system.  It was used primarily for the ease of implementation, and because at this stage real-time operations are not required.  However, for this system to be realistically useful, a better communication method needs to be developed -- either a faster serial bus or some form of parallel connection.

	\subsection{The processor} % (fold)
	\label{sub:the_processor}
		% Weak points
		% The MFCC calculation has several problems.  The library used is slow and inefficient, and doesn't match the results given by HTK.


	% subsection the_processor (end)

% section analysis_of_solution (end)


% chapter design_approach (end)